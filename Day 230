Day 230/250: Minimum ASCII Delete Sum for Two Strings

Problem Statement #712

Problem Statement Explanation:

Given two strings s1 and s2, return the lowest ASCII sum of deleted characters to make two strings equal.

Example:
Input: s1 = "sea", s2 = "eat"
Output: 231

Explanation: Deleting "s" from "sea" (ASCII 115) and "t" from "eat" (ASCII 116) results in "ea" for both. The total sum is 115+116=231.

Solution Approach:

This problem is a variation of the Longest Common Subsequence (LCS). 
Instead of finding the length of the longest matching sequence, we track the "cost" of deletions.

1. State Definition
We use a 2D array dp[i][j] where dp[i][j] represents the minimum ASCII delete sum to make the prefixes s1[0...i-1] and s2[0...j-1] equal.

2. Base Cases
dp[0][0] = 0: Two empty strings are already equal.
dp[i][0]: To make a string of length i equal to an empty string, we must delete all characters in s1.
dp[0][j]: To make an empty string equal to a string of length j, we must delete all characters in s2.

3. Transition Logic
For each character pair s1[i-1] and s2[j-1]:
If characters match: No deletion cost is added.
dp[i][j]=dp[i−1][j−1]
If characters don't match: We have two choices and we pick the minimum:
Delete s1[i-1]: dp[i-1][j] + ASCII(s1[i-1])
Delete s2[j-1]: dp[i][j-1] + ASCII(s2[j-1])

Here's the code:

class Solution {
    public int minimumDeleteSum(String s1, String s2) {
        int m = s1.length(), n = s2.length();
        int[][] dp = new int[m + 1][n + 1];

        for (int i = 1; i <= m; i++) dp[i][0] = dp[i-1][0] + s1.charAt(i-1);
        for (int j = 1; j <= n; j++) dp[0][j] = dp[0][j-1] + s2.charAt(j-1);

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (s1.charAt(i-1) == s2.charAt(j-1)) {
                    dp[i][j] = dp[i-1][j-1];
                } else {
                    dp[i][j] = Math.min(dp[i-1][j] + s1.charAt(i-1), 
                                        dp[i][j-1] + s2.charAt(j-1));
                }
            }
        }
        return dp[m][n];
    }
}

Complexity:

Time Complexity:	O(M×N)	
Space Complexity:	O(M×N)	




