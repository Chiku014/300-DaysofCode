Day 221/250: Plus One 

Problem Statement #66

Problem Statement Explanation:

You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. 
The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.
Increment the large integer by one and return the resulting array of digits.

Example 1
Input: digits = [1,2,3]
Output: [1,2,4]

Explanation: The array represents the integer 123. Incrementing by one gives 123 + 1 = 124.

Example 2
Input: digits = [9]
Output: [1,0]

Explanation: The array represents the integer 9. Incrementing by one gives 9 + 1 = 10.

Solution Approach:

To solve this efficiently, we simulate manual addition (schoolbook addition) starting from the last element of the array.
Right-to-Left Traversal: We iterate through the array starting from the last index (n - 1).
Handling Non-Nine Digits: If the current digit is less than 9, we simply increment it by 1 and return the array. This is the "best-case" where no further carries are needed.
Handling Nine Digits: If the digit is 9, incrementing it makes it 10. We set the current position to 0 and continue the loop to carry the 1 to the next significant digit.
The "All Nines" Case: If the loop finishes without returning, it means every digit was a 9 (e.g., 999). In this case, we create a new array with a length of n + 1, set the first element to 1, and return it. (Java initializes the rest of the elements to 0 by default).

Here's the code:

class Solution {
    public int[] plusOne(int[] digits) {
        int n = digits.length;

        for (int i = n - 1; i >= 0; i--) {
            if (digits[i] < 9) {
                digits[i]++;
                return digits;
            }
            digits[i] = 0;
        }

        int[] newNumber = new int[n + 1];
        newNumber[0] = 1;
        
        return newNumber;
    }
}

Complexity:

Time Complexity: O(n)
Space Complexity: O(n)




